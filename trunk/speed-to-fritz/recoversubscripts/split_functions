#!/bin/bash
# Converts little endian 4-byte unsigned integer given as spaced hex string
# into decimal number (e.g. "00 D0 4C 00" -> 5033984)
hex2dec()
{
# ATTENTION, 'strtonum' is gawk-specific, other awk versions like mawk
# probably do not know it.
echo "$1" | gawk '{ printf "%d\n", strtonum("0x" $4 $3 $2 $1) }'
}
extract_exe()
{
echo -e "\nExtracting executeabel endpart ..."
n=1
kernel_lines="$(tools/hexgrep "$KERNEL_MAGIC" "$input_file")"
exe_length=($(echo "$kernel_lines" | sed 's/:.*//'))

output_file="$output_dir/recover.exe"
echo " recover.exe, start @ 0, length: $exe_length"
dd if="$input_file" of="$output_file" ibs=1 obs=8192 count=$exe_length 2> /dev/null
}
extract_exe_mid()
{
echo -e "\nExtracting end part off kernel.image ..."
n=1
act_size="$(tools/hexgrep "$BOOTLOADER_MAGIC" "$input_file" | sed 's/:.*//')"
msize="53"
offs=$((act_size - msize))
output_file="$output_dir/exe_mid"
echo " exe_mid, start @ $offs, end @ $act_size "
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=$offs count=$msize 2> /dev/null
echo
echo -n "Firmware version: "
dd if="$output_file" bs=1 count=16 2> /dev/null
echo
}
extract_exe_end()
{
echo -e "\nExtracting executeabel endpart ..."
n=1
act_size=`ls -l "$input_file" | sed -e 's/[^0-9]/#/g' | sed -e 's/#\+[0-9]\+#\+\([0-9]\+\).*/\1/'`
offs="$(tools/hexgrep "$BOOTLOADER_MAGIC" "$input_file" | sed 's/:.*//')"
offs=$((offs + 65536))
esize=$((act_size - offs))
output_file="$output_dir/exe_end"
echo " exe_end, start @ $offs, length: $esize, end @ $act_size"
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=$offs count=$esize 2> /dev/null
}
# Extracts urlader.image candidates from input file, based on bootloader magic
# string. Applies heuristic check for typical strings occurring in AVM
# bootloaders. Detects older ADAM as well as newer EVA bootloaders.
extract_bootloader()
{
echo -e "\nExtracting bootloader (urlader.image) ..."
n=1
for bootloader_offs in $(tools/hexgrep "$BOOTLOADER_MAGIC" "$input_file" | sed 's/:.*//'); do
output_file="$output_dir/urlader.image"
n=$((n+1))
bsize=65536
act_end=$((bootloader_offs + bsize))
echo " urlader.image, start @ $bootloader_offs, length: $bsize, end @ $act_end"
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=$bootloader_offs count=$bsize 2> /dev/null
grep -iq 'entering passive mode' "$output_file" \
&& grep -iq 'ftp server ready' "$output_file" \
&& echo " file is a possible bootloader candidate" 
done
[ $n -eq 1 ] && echo " No bootloader candidate found!"
}
extract_kernel_plus_mid()
{
echo -e "\nExtracting root kernel (kernel.image) ..."
n=1
kernel_lines="$(tools/hexgrep "$KERNEL_MAGIC" "$input_file")"
kernel_offs=($(echo "$kernel_lines" | sed 's/:.*//'))

bootloder_offs="$(tools/hexgrep "$BOOTLOADER_MAGIC" "$input_file" | sed 's/:.*//')"
psize=53
n=$((n+1))
kernel_end=$((bootloder_offs - psize))
dd_count=$((kernel_end - kernel_offs))
output_file="$output_dir/kernel.image"
echo " kernel.image, start @ ${kernel_offs}, length: $dd_count, end @ $kernel_end"
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=${kernel_offs} count=$dd_count 2> /dev/null

output_file="$output_dir/exe_mid"
echo " exe_mid, start @ $kernel_end, length: $psize, end @ $bootloder_offs "
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=$kernel_end count=$psize 2> /dev/null
echo
echo -n "Firmware version: "
dd if="$output_file" bs=1 count=16 2> /dev/null
echo
}
# Extracts kernel.image candidates from input file, based on kernel and
# SquashFS magic strings.
# calculated from assumed length header field is close enough to subsequent
# SquashFS start offset.
# firmwares, but currently no other image types.
extract_kernel_image()
{
echo -e "\nExtracting kernel.image ..."
kernel_lines="$(tools/hexgrep "$KERNEL_MAGIC" "$input_file")"
#echo "kernel magic line: $kernel_lines"
kernel_offs=($(echo "$kernel_lines" | sed 's/:.*//'))
#echo "kernel offset: $kernel_offs"
#echo -n "kernel length in hex: "
#echo "$kernel_lines" | sed -r 's/^[0-9]+:.{12}(.*).{27}/\1/'
kernel_length=($(hex2dec "$(echo "$kernel_lines" | sed -r 's/^[0-9]+:.{12}(.*).{27}/\1/')"))
#echo "kernel length in decimal: $kernel_length"
squashfs_lines="$(tools/hexgrep "$SQUASHFS_MAGIC" "$input_file")"
#echo "squashfs magic line: $squashfs_lines"
squashfs_offs=($(echo "$squashfs_lines" | sed 's/:.*//'))
#echo "squashfs offset: $squashfs_offs"
#echo -n "squashfs length in hex: "
#echo "$squashfs_lines" | sed -r 's/^[0-9]+:.{24}(.*)/\1/'
squashfs_length=($(hex2dec "$(echo "$squashfs_lines" | sed -r 's/^[0-9]+:.{24}(.*)/\1/')"))
#echo "squashfs length in decimal: $squashfs_length"
#ls -l "$input_file"
act_size=`ls -l "$input_file" | sed -e 's/[^0-9]/#/g' | sed -e 's/#\+[0-9]\+#\+\([0-9]\+\).*/\1/'`
echo "File sizes: $act_size"
dd_count=$((squashfs_offs - kernel_offs + squashfs_length))
##older firmwaews used to have zerro bytes added
#dd_count=$((((squashfs_offs - kernel_offs + squashfs_length) | 0xFFF)+1))
echo "n\File sizes: $dd_count"
output_file="$output_dir/kernel.image"
echo " kernel.image, start @ ${kernel_offs}, SquashFS @ ${squashfs_offs}, length: $dd_count, end @ $act_size"
dd if="$input_file" of="$output_file" ibs=1 obs=8192 skip=${kernel_offs} count=$dd_count 2> /dev/null
}
